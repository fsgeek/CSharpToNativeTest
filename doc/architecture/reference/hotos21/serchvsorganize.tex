\section{Search}\label{sec:search}
\reto{Somehow I feel there is a difference in "locating" the object and "searching" the object. }
\tm{I agree, they \textit{are} different.  Humans fall back to ``searching'' when ``locating'' fails them.  I'm convinced that part of what a good visualizer does is disguise \textit{search} as \textit{navigation}. Look at Ashish's demo: what he's doing shows aspects of faceted search (the slider bars) but what's being displayed has the ``look and feel'' of navigation.}

Hierarchical namespace organizes data into components that enable an intuitive search. In fact, the only reason we organize data into directories is to enable a search that maps with its organization. 
Unique filenames are achieved through unique paths. Our search is based on the assembly of these unique components of a path. However, just because you store the files in the same directory, does not mean that the files are stored near each other on the disk, or even on the same machine. So, while a directories are used for organizing related files together, this organization is done with a purpose of searching files; organizing files in one directory ties them together. Thus a directory provides you a common attribute for related files.  
In a way, every component of the path to a file from the root directory become the attributes of the file. This works only because we loosely associate specific filenames to their contents based on the components of the filenames. For eg: /etc/app/foo.txt could be a configuration for the entire system whereas the ~/.app/foo.txt could be a configuration for a particular user; the pathname dictates the context and thus the semantics. 
\reto{What if you have two pathnames for the same file, with conflicting semantics?}
\reto{Isn't a directory merely defining a context in which a name is resolved? this should be inline with\cite{Saltzer1978}}

Such a hierarchical name based organization and search has worked in the past when users used to have fewer files. With separate storage spaces and a gazillion files, maintaining the path based uniqueness while guaranteeing successful human memory based search for file context/semantics becomes difficult. On top of this, some storage silos do not support hierarchical namespaces. Representing these non hierarchical namespaces in your traditional hierarchical namespace is akin to using a circular cover for a square drain hole. Despite doing this, as the storage space grows in size, the number of components in a path or the number of paths are forced to grow. Thus accurately associating paths with the contents of the files becomes humanly impossible, making search a time consuming and repetitive affair. Apart from difficult search, organizing these gazillion files is equally hard. The burden of organizing these gazillion files in a hierarchical organization lies with the humans that created the files. Furthermore, the only reason we carry this burden is to be able to search the files that we want. Thus we need to be able to search based on attributes of a file while disassociating ourselves from file organization.

Hierarchical namespaces provide implicit attributes that tie related files in an organized way and enable searching of these files through them. In a hierarchical organization, pathname components of a file are the implicit search attributes. In the simplest case, we can imagine using these same attributes in a non hierarchical organization by associating them explicitly with the files while disassociating them from how they are organized.  Just like users don’t need to care where on the physical disk the related files are stored, they don’t need to care how these files are organized, as long as they can be found and retrieved.

\reto{why? -- somehow I don't care much about the friendly name of the object, as long as I am able to locate it somehow. }
To enable file search, the user needs to tie the contents of the file with some name that reminds the user of the contents of the file. The user defined name of the file need not be unique. When we transfer the burden of organizing files on the software that performs this task, that software can create unique name for the file that is different than the one assigned by the user. The software defined non human interpretable name is of no consequence to the user as it is used for file organization and retrieval. The human defined non unique name is used as one of the attributes for searching a file. When a file is not organized by a human, the explicit attributes of the file are thus more important than where and how the files are organized and stored. From a user’s perspective there can be multiple files with the same last component name i.e “foo.txt” but with different attributes. For eg: just like /etc/app/foo.txt is different than ~/.app/foo.txt, now we have two foo.txt with different attributes. One file can have the following attributes “foo.txt”, “app”, “etc” whereas the other can have “foo.txt”, “app” and “~”. Ofcourse there can be many other attributes that the files can have. These other attributes can make the search more accurate. Users can now search based on attributes than on pathnames. A simple way to imagine path component like search is to use the same path based components as the attributes of the file that we search.  While searching users can create virtual pathnames for search based on the attributes. However, the pathnames need not be in the exact order like they have to be in the directory based pathnames. For eg: “students/recommendation/tony” will search files that have the three attributes identified by the pathnames. However, note that these pathnames are only searching the attributes. The same files will be searched for “recommendation/students/tony” or “tony/recommendation/students/” as “/” is used as an “attribute separator” rather than path separator. Names of files can now be of the type “foo.txt” alone. There can be multiple foo.txt shown. The difference between the different “foo.txt” can be found out using “stat foo.txt” that will show all the attributes associated with the two files. A “diffstat” command could also show the difference in attributes of the two files.
