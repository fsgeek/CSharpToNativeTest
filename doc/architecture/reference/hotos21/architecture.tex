% Basically we need a term to name what a user provides to a namespace service. Tony used 'name' which is, I think, overloaded. I'm using reference now, but I am open to a better name.
% A quick list of synonyms for "name" (taking the liberty to omit those that seem to conflict with existing usage): designation, epithet, moniker, appellation, cognomen, appellative.
% I like moniker, actually but cognomen might be good since it's not a term I use much.  Definition of cognomen (I had to look it up): "an extra personal name given to an ancient Roman citizen, functioning rather like a nickname and typically passed down from father to son."   See https://en.wikipedia.org/wiki/Cognomen
% actually, I think gnomen might be better (e.g., "nomenclature").  I'll go with that unless there's a consensus to use something else.
% Turns out to be moot at this point: we don't use \REF in any of the surviving text.  At the moment we use "name" in four different contexts.


% Projection is less of a concern, but I think I'm going to go with "view".

% The term "attribute" should not be used in general form.

\newcommand{\REF}{reference}
\newcommand{\PROJECTION}{view}

\section{The Nirvana Architecture}\label{sec:arch}

%\begin{figure}
%  \begin{center}
%  \begin{footnotesize}
%    \begin{tabular}{|cp{0.75\columnwidth}|}\hline
%        silo & stores objects\\
%        object & the file's content\\
%        meta-data & the files attributes/properties\\
%        key & the unique identifier of the object\\
%        namespace & defines name context, high-dimensional attribute space \\
%        projection & construction a lower-dimensional namespace from a higher-dimensional namespace\\
%        name & a friendly/meaningful object name within the namespace. \\
%        locate & the process of obtaining an object's key within a context/namespace. \\
%        search & the process of locating an object based on a search query. \\
%        navigate & the process of locating an object based on following meaningful names \\
%        Overall & I think this is powerful: the user can define the namespace and its projections.
%    \\\hline\end{tabular}
%\end{footnotesize}
%    \end{center}
%  \vspace{-4mm}
%    \caption{Terminology (will go away for final submission)}
%  \label{fig:terminology}
%\end{figure}


% Surbhi asks that I include multiple cloud storage silos in the picture.  I wonder if we could add network file systems as well; I just didn't want them to be below
% the namespace.
% Puneet indicates that the text is too small.  We both agreed this needs to be centered and a bit larger (it feels like I'm wasting space).

%\mis{I did a commit before changing this section, but I wanted to tweak some terminology and provide a gentler introduction to this section. I worry that asking the reader to adopt a whole new terminology before telling them what we are really proposing is too great a burden.}
%\tm{I actually agree; defining the terms up front is, however, a useful tool for us when writing the text.}

We propose separating context/semantic naming from location and exposing this to users.
This separation will enable users to navigate/search data across multiple silos independent of where data is stored, and their organization preferences.
To realize this, we present the Nirvana architecture.
In Nirvana, storage silos need not change how they store objects, assign them silo-local \textit{location} names, 
support their choice of attributes, and provide ways for users and other services to access them.
More interestingly, we absolve storage silos from providing \textit{context/semantic} names.
Instead, we introduce \emph{Nirvana namespaces} and \emph{namespace services}, which integrate one or more silos to provide \textit{context/semantic} names and access capabilities. In the following discussion, we use the term \emph{object} to refer to a discrete unit of storage, such as a file stored in an existing storage silo. Objects can reside on device-local file systems or in the cloud. Users access objects via requests to namespace services, which can be either local or cloud-based (see Fig.~\ref{fig:systemsarchitecture}).

\paragraph{Namespaces} In a Nirvana namespace, the name of a data object simply becomes a \textit{collection of metadata attributes}. Attributes are tuples consisting of, e.g., type, name, value, and author.
To date, we have identified three attribute types: \emph{authoritative}, \emph{annotated}, and \emph{autogenerated}.
Authoritative attributes are statements of fact provided by the silo, e.g., file size, creation time, content hash.
The author of an authoritative attribute is the silo containing the object; if the object is replicated in multiple silos, the author is the originator of the object.
Annotated attributes are provided by users or applications, e.g., Word document attributes, user-supplied tags, image metadata.
The author of such attributes is the user or program providing the annotations.
Finally, autogenerated attributes are produced by services, e.g., the cat video detector, a keyword extraction service.
Authors are responsible for defining the semantic meaning of their attributes.
Nirvana allows an unbounded number of attributes per object and requires only one: the authoritative location attribute, 
which is a set of identifiers that refer to the silo and silo-local name(s) by which an object can be accessed.


%In the following discussion, we use the term \emph{object} to refer to a data element stored on and managed by Nirvana.
%Objects can reside on device-local file
%systems, network attached file systems (e.g., CIFS/SMB, NFS),
%distributed storage that projects onto a local storage silo (e.g., %OneDrive, Dropbox), and
%cloud storage systems of any type
%(e.g., Amazon S3, Azure Cosmos, Oracle Server, MongoDB).
%Users access objects via requests to namespace services, which can be either local or cloud-based services.\footnote{If a cloud-based services is used, we assume a caching layer on the local device to ensure access to data during disconnection. In the simplest case, the caching layer degenerates to the local file system namespace.}

\paragraph{Namespace Services}

The namespace service provides support for three basic operations: (1) the ability to create a Nirvana \REF, which is a set of metadata attributes;
(2) the ability to map a {\REF} to the underlying storage location and vice versa; and
(3) the ability to query the namespace to find {\REF}s that match a  pattern.  These {\REF}s are immutable: deletion is achieved using a tombstone and update by creating a new {\REF}, with a new creating timestamp.  This preserves history and allows versioning, assuming storage silo support.

% Moved from Intro to here.  See if we can capture it.
% Location is usually a one-to-one, or one-to-many relationship.
% Context/meaning are many-to-many relationships.

%A Nirvana namespace service runs on a local system or in the cloud, may work with an OS-integrated 
A \textit{namespace provider} may also provide an API used by applications to interact with namespaces, allowing construction of new visualization and search tools. 
For example, if you are searching from your smartphone, you can find a specific document, regardless of where
it is stored, whether that is your cloud storage system, a desktop computer, or some other storage location and even if it is not presently accessible.  
Conversely, this model can be constructed to permit maintaining multiple distinct namespaces, so that each user is able to see \emph{{\PROJECTION}s} of their own data.

\paragraph{Locating specific objects} From our description so far, it seems that Nirvana is all about providing fertile ground for effective search, but it may be unclear how the user could \textit{locate} the specific object they need. We provide an example to illustrate how Nirvana can support this. 

% Traditionally. Name and hierarchy of directories.
% In Nirvana, these can become attributes, and a namespace provider can simulate a legacy hierarchical namespace. Support users who find it useful and legacy tools, such as compilers. 
% At the same time, allows users to gently depart from this model. For example, HPC community embed metadata elements of their objects into file names, users can now store these  elements explicitly with the name service, while also retaining the desired part of an old-fashioned name as a separate metadata element. 

In traditional systems, a user gives a file a memorable name, e.g., \texttt{eddie.txt}. 
In addition, hierarchical directory structure provides additional context for the object, helping the user locate the precise instance of \texttt{eddie.txt} that they need. 
For example, there can be a \texttt{faculty/recommendations/eddie.txt} and \texttt{papers/fantasstic/eddie.txt}. 
Nirvana supports locating objects via memorable names by assigning the object a user-provided attribute, e.g., \texttt{eddie.txt}. 
Similarly, to simulate navigation by directory hierarchy, an object can be assigned attributes corresponding to the path components. 
In this way, Nirvana can also support legacy tools relying on hierarchical directory namespaces.

At the same time, Nirvana can help users go beyond using memorable names. 
For example, in the experimental science community, users traditionally embed the experiment context into the name of their data files~\cite{guo2012burrito}. 
In Nirvana, users can explicitly store those metadata elements in a namespace. 
Then, grepping for, say, \texttt{experiment-data.txt} can return multiple instances, but their metadata attributes can be explained via \texttt{stat}, and a \texttt{``diffstat''} command could also show the differences in the attributes between the two {\REF}s.

While hierarchical file system provide us with path and file names for search, our approach can make use of other augmented metadata elements, allowing us to narrow the results.

% (1) We don't lock ourselves into a set of attributes, so we don't need prescience. We don't need a big centralized indexer that knows all about all types of files.
% (2) We can customize these "tags" based upon the user's own behavior, and can be added to an indexing list.
% We can use the attributes to provide the "most relevant" results in the visualization tool(s). 


\paragraph{Sharing, Access Control and Privacy}
% - access control  -> who can access the file, what part of the file, what attributes (all, just a subset, ?)
Enabling safe sharing requires a clear model of access control and a clear understanding of possible privacy implications. 
While traditional file systems do have a vague notion of namespace access control using directory permissions, we are now faced with two explicit levels requiring access control: the object itself and the metadata. 

What rights exist on each level and how do they relate to each other? 
In Nirvana, possession of the {\REF} does not imply any rights to access the object, since access is managed by the storage silo itself.  
The namespace provider has the ability to encode encrypted values within metadata elements, which also allows storing of sensitive information within the name without compromising security --- anyone with the Nirvana {REF} must still also have the relevant key to understand the value of specific attributes. 
Similarly, this permits storing metadata in a third party service without compromising the contents of the metadata attribute.  
%Utilizing digital signatures to protect the metadata element can be used to verify that the decryption key used is correct, or it can be used to verify that the value itself did originate with the specified authority to prevent spoofing.  This ability to secure individual metadata elements against tampering protects from malicious actors tampering with metadata elements as well as permits users to define their own unique rings of trust based  upon their own (or their organization's) criteria.

%Intuitively, a user may only perform an operation above if they posses the corresponding rights. There are two access control methods: access control lists and capabilities. Which form will prevail for namespaces and for the objects themselves?

%In addition, there might be certain rights a user needs to have in order to further share the object (or namespace) with other users or add the object to another name space. How can we revoke the rights from users and who is allowed to revoke -- is this an explicit right or implicitly given to the owner?

%Namespaces may contain many properties of their objects that in turn contain many bytes of data. Can we assign rights to particular properties or bytes? 
%\reto{github access token}
%\tm{Remember in Twizzler, where they constructed objects via composition?  I'd argue that you \textit{could} do exactly the same thing and use it to control logical regions.  That's definitely not something we do with the existing APIs, but it could be something a file system permitted via a more flexible interface.}

%Given that a name in Nirvana includes the metadata necessary to locate the object in the global storage space using a URI, it is easy for names to be shared between namespaces.  There is no inherent requirement that the recipient of names need trust the metadata elements of that namespace in the same way the original owner did --- each user can define their own unique "rings of trust" with respect to individual metadata elements.

An important element of the Nirvana namespace model is the ability to identify not only the \textit{type} of a metadata attribute, 
but also the \textit{authority} that provided such data.  
To accomplish this, we need to have a mechanism for allowing verifiable identification for the metadata attributes that make up the name.  
However, rather than propose a new identity and access management (IAM) service,
we simply note that we expect Nirvana to work with a least one such service (Fig.~\ref{fig:systemsarchitecture}). 
In addition, this model also allows for a specific treatment of trust relationships that need not rely upon the namespace itself.  
In essence, this allows the user to define their own ``security rings of trust.''

Nirvana Namespaces detect storage changes via a publish/subscribe model, similar to prior work~\cite{birman1987exploiting,9229638}.

%A second important aspect of Nirvana is knowing when to update the contents of the namespace.  Because the namespace and storage are now separated, it is likely that applications will change the contents of the namespace.  This is similar to the challenge faced by network file systems, and we propose adoption of a similar solution that has been used in recent work~\cite{9229638} but is based on the decades old model of asynchronous messaging, the ``publish/subscribe'' model~\cite{birman1987exploiting}.  While many storage providers already provide an interface consistent with this model, it is possible to simulate this as well using periodic scans, whether within the storage silo or from the client of that silo.

%An important aspect of Nirvana is choosing what goes into its namespace.  Certainly one option is to simply have it include \textit{all} content, across all silos, though it is not clear to us if this is the \textit{best} approach.  Thus, we do not define what must be placed in Nirvana, leaving that as an open question.

%A second important aspect of Nirvana is knowing when to update the contents of the namespace.  Because the namespace and storage are now separated, it is likely that applications will change the contents of the namespace.  This is similar to the challenge faced by network file systems, and we propose adoption of a similar solution that has been used in recent work~\cite{9229638} but is based on the decades old model of asynchronous messaging, the ``publish/subscribe'' model~\cite{birman1987exploiting}.  While many storage providers already provide an interface consistent with this model, it is possible to simulate this as well using periodic scans, whether within the storage silo or from the client of that silo.


%In its simplest form, a namespace service is a map from a user-provided {\REF} to a <silo, silo-local name> tuple.A reference, however, is a query in a rich metadata space.\tm{I find this confusing: is a \REF a mapping tuple, or is it a query? Doesn't the sentence immediately before this say it's a query? The namespace is a map ...}
%Object metadata is a set of \emph{metadata elements} (elements for short), which are tuples consisting of type, name, value, and author.To date, we have identified three element types: \emph{authoritative}, \emph{annotated}, and \emph{autogenerated}.Authoritative elements are statements of fact provided by the silo, e.g., file size, creation time, content hash.The author of an authoritative element is the silo containing the object; if the object is replicated in multiple silos, the author is the originator of the object.Annotated elements are provided by users or applications, e.g., Word document attributes, user-supplied tags, image metadata.The author of such elements is the user or program providing the annotations.Finally, autogenerated elements are produced by services, e.g., the cat video detector, a keyword extraction service.Authors are responsible for the semantic meaning of their tags.Nirvana allows an unbounded number of elements per object and requires only one: the authoritative name element, which identifies the silo and silo-local name by which an object can be accessed.\tm{"the" implies only a single name element.  Is there a reason we can't have zero (tombstone) or more than one (replication)?  As written, this conflicts whith what I wrote in the end of this section; these need to be reconciled.}
%{\REF}s are then simply queries against sets of metadata elements, with the simplest query that of specifying a silo and silo-local name.

%\mis{Given this description, do we need the notion of projection? Do we need the notion of a Nirvana key?  We might, but I'm not sure.}
%\tm{We used the term ``projection'' to describe the synthesized directory we were creating to satisfy the demands of persistent naming that can be taken from the namespace and given to an application. Perhaps "view" is better?  I added a more detailed note at the top of the source file.}

%\paragraph{Namespace service providers}

%Figure \ref{fig:systemsarchitecture} illustrates the Nirvana architecture.

%Nirvana includes a namespace provider that is integrated into the operating system.  This can provide support for legacy namespace \PROJECTION, which is needed to allow existing applications to use the Nirvana namespace.  In addition, this OS integrated component works with a user level service that facilitates the composition of the local namespace with a global namespace provider.  In this way, namespace {\PROJECTION}s can be created for global resources of interest to the user of the given namespace.  This model can be constructed to permit maintaining multiple distinct namespaces, so that each user is able to see {\PROJECTION}s of their own data.

%Given that a name in Nirvana includes the metadata necessary to locate the object in the global storage space using a URI, it is easy for names to be shared between namespaces.  There is no inherent requirement that the recipient of names need trust the medata elements of that namespace in the smae way the original owner did --- each user can define their own unique "rings of trust" with respect to individual metadata elements. Similarly, they can choose to construct a new name by adding or removing metadata elements that are appropriate for their own use.  Possession of the name does not imply any rights to access the object, since access is managed by the storage silo itself.  The ability to encode encrypted values within metadata elements also allows storing of sensitive information within the name, without compromising security --- anyone with the name must still also have the key to understand the value.

%The Nirvana namespace service runs on a local system, may work with an OS-integrated namespace provider but may also provide an application programming interface (API) that may be used by applications to interact with namespaces \textit{independent} of the kernel integrated component.

%The Nirvana Namespace as a Service component is a separate, distinguished namespace that can be used to share namespace data across multiple devices.  One motivation for this is that it permits tying namespaces from multiple distinct silos together, which can more easily enable human users to find specific objects, regardless of the silo in which that information is stored.  In other words, if you are searching from your smartphone, you can find a specific document, regardless of where it is stored, whether that is your cloud storage system, a desktop computer, or some other storage location.  This helps us realize ``location oblivious naming'', which better fits with the way in which we search for data.

%\paragraph{Nirvana Naming Service Providers} 
%The namespace service provides support for just three basic operations: (1) the ability to create a name, by specifying a metadata list;
%(2) the ability to map a name to the underlying storage location and vice versa; and
%(3) the ability to query the namespace to find names that match a specific pattern.
%This general definition of a name is an extension to the common usage pattern of embedding metadata within the name of files: all the metadata is part of the unique name of the file.  This allows us to support deletion via a tombstone model, in which a name is created without any associated storage metadata.

%The ability to map a name to the underlying storage is a minimum requirement for a viable system; however, the ability to map a storage location to names which reference that object is also useful.  For example, in order to be compliant with the GDPR, \textit{anyone} that stores information about a specific person or event might be called upon to purge that information --- this is the ``right to be forgotten''.  Being able to take the material that needs to be forgotten and find all references to it will be useful. 

%Similarly, we have included the ability to secure the data contents of a metadata element because this would permit storing metadata in a third party service without compromising the contents of the metdata value element.  Utilizing digital signatures to protect the metadata element can be used to verify that the decryption key used is correct, or it can be used to verify that the value itself did originate with the specified authority to prevent spoofing.  This
%ability to secure individual metadata elements against tampering protects against malicious actors tampering with metadata elements as well as permit users to define their own unique rings of trust based  upon their own (or their organization's) criteria.

%An important aspect of Nirvana is choosing what goes into its namespace.  Certainly one option is to simply have it include \textit{all} content, across all silos, though it is not clear to us if this is the \textit{best} approach.  Thus, we do not define what must be placed in Nirvana, leaving that as an open question.

%A second important aspect of Nirvana is knowing when to update the contents of the namespace.  Because the namespace and storage are now separated, it is likely that applications will change the contents of the namespace.  This is similar to the challenge faced by network file systems, and we propose adoption of a similar solution that has been used in recent work~\cite{9229638} but is based on the decades old model of asynchronous messaging, the ``publish/subscribe'' model~\cite{birman1987exploiting}.  While many storage providers already provide an interface consistent with this model, it is possible to simulate this as well using periodic scans, whether within the storage silo or from the client of that silo.

%\paragraph{Identity and Access Management} 

%An important element of the Nirvana namespace model is the ability to identify not only the \textit{type} of a metadata element, but also the \textit{authority} that provided such data.  To accomplish this, we need to have a mechanism for allowing verifiable identification for the metadata elements of the name.  However, rather than propose a new identity and access management (IAM) service, we simply note that we expect Nirvana to work with a least one such service (Fig.~\ref{fig:systemsarchitecture}).

%If the IAM service is unavailable, the origin cannot be verified, or the metadata element does not include the necessary verification data, then they can be treated as unverified metadata, and as such they can be handled appropriately.  In addition, this model also allows for a specific treatment of trust relationships that need not rely upon the namespace itself.  In essence, this allows the user to define their own ``security rings of trust.''

%\paragraph{Data Provenance}

%\reto{tried to summarize something about the trustworthiness of attributes coming from specific sources}

%Besides access control on the object \emph{and} the attributes including an appropriate privacy and access control measures, there is the notion on the trustworthiness of elements. For example, the size of the object and its type can be seen as authenticated by the object itself.
%\tm{I think we already addressed this above; we probably don't have space/time to state this twice.}
%However, other attributes such as ``subject=kangaroo'' or ``location=Australia' might be added by an automated system, other users or by the user itself. 
%In Nirvana, each attribute has a clear origin: the user or automated system (e.g., an attribute provider) who added the attribute.
%\tm{This now conflicts with what we said earlier.  Need to reconcile.}
%The owner of a namespace may select the trustworthiness of the attributes from a specific source, up to the point to classifying attributes from certain sources as ``spam''. 
%Similarly, the trust-score of a user/system is used to allow an attribute to be updated if the new source has a higher level of trustworthiness, e.g. updating the location to a more specific location. ``location=New South Wales, Australia''.  The actual implementation of the trust-score can be namespace specific, and may range from a ``pagerank'' style system, to a ring-based model, or a simple upvote/downvote. 

%\reto{trust-score providers ? -- don't know, but something like Equifax for an attribute provider's trustworthiness sound somewhat horrible.}
%\tm{I think we punt this problem, or we make it a research question (which is sort of the same thing).}

%\reto{about billing: on storage / attributes / queries / transfer / ... }
%\tm{This is likely more important when we get to the NaaS model.  I've included the Namespace as a Service in the architecture, but I'm not sure I want to broach this topic at this point.  Would it make sense for us to turn \textit{this} into a research question as well?}

%\paragraph{Namespace Interface}

%While we consider this an open research question (\S \ref{sec:research}) we propose starting with a simple set of operations that apply to the namespace: create, map, and query. We note that the existing interface for I/O is likely sufficient, though additional work on melding these two interfaces together to both provide legacy support and a more flexible file system API remains an open question.

%In our model a \textbf{create} would consist of a new \textbf{name} and a set of locations, where each location is a Uniform Resource Identifier (URI).   A name can be deleted by creating a new name, a metadata element indicating that this is a tombstone, and an empty set of locations.  The namespace provider would add a metadata element indicating the time that this name was added to the namespace. We have several goals for this operations: it permits versioning by the namespace provider though it is not required; it allows maintaining history, though it can certainly be pruned.  The locations can be interpreted, depending upon the metadata elments of the name, as being a composition or replication of the file.  We expect our initial system will include definitions of a number of metadata elements, but our goal in specifying a type is to use an identifier space that can be uniquely generated without a central authority, such as a UUID.  We expect there to be a ``friendly name'' associated with such well-known metadata element types as well, such as ``creation time''.

%The \textbf{map} operation is responsible for taking a \textit{name} and providing a mapping of that name to a set of locations.  We expect that it will be similarly useful to be able to map a set of locations to a list of names that reference the name, but we leave that determination as an open question for this proposal.

%The \textbf{query} operation is responsible for taking a \textit{query operation} and returning a list of \textit{names} that match the query operation.  Queries can be used to find specific names within the namespace for consumption by an application, or they can be used by the namespace service to create {\PROJECTION}s.  We suggest that the query language itself should be sufficiently rich that it can specify the specific metadata elements that should be used to match these queries.

%One common operation in a legacy hierarchical file system is to enumerate the contents of a directory.  One possible model for this would be to then specify a query that indicates the identity of the containing directory and then return all names in which that containing directory is specified in its metadata. For legacy applications, this could then be presented via a traditional directory enumeration API (e.g., getdents or NtQueryDirectoryInformaation).  Key challenges will be ensuring that the query language can express the relevant queries as well as ensure that the resulting system is optimized to processing those queries and providing them back to the caller.

